## 한정사

`qualifier(한정사)`는 `data type`에 대해 추가적인 정보를 제공해주는 `keyword`입니다.  

`qualifier`는 데이터가 차지하는 메모리의 크기에 영향을 미치지 않으며,   
각각의 비트가 어떻게 해석되어 값을 결정하는지에도 영향을 미치지 않습니다.   
즉, `qualifier`가 붙어있든 안 붙어있든 원본 `data type`을 위해 메모리에 저장되어있는 비트들은 정확히 같습니다.   

대신에 `compiler`가 `code`를 `compile`할 때,   
해당 데이터가 어떻게 `access` 되어야 하고 어디에 `store` 되어야 하는지 `qualifier`를 보고 분석합니다.   

이들은 언어로 치면 형용사와 비슷합니다:   
"a fickle man", "a volatile int", "an incorruptible lady", "a const double".

## 타입 한정사

`type qualifier`는 세 가지가 있습니다: `const`, `volatile`, `restrict`.   

자주 볼 가능성이 큰 순서입니다.   
`const`는 굉장히 자주 보겠지만, `restrict`는 그렇지 않겠죠.   

이들은 `data type`의 일부로서 부여되는 `qualifier`입니다.   
물리적으론 같은데 논리적으로는 다른 `data type`을 만들어냅니다.   

예를 들어 `int`와 `const int`는 완전히 똑같은 형태로 메모리에 저장되지만,   
`access` 조건이 달라지면서 다른 `data type`이 됩니다.   
`compiler`도 `int`와 `const int`에 대해 서로 다른 `data type`이라고 보고합니다.

- const

여러분이 마주칠 99%의 `qualifier`는 `const`입니다.   
`constant(상수)`의 준말로,   
어떠한 값이 변하지 않는 값, 즉 `read-only value`임을 나타낼 때 쓰죠.

```cpp
int m = 2;
const int n = 3;

m = 5;
// n = 6;   const는 read-only!
```

`C++` 세상에 오는 순간 `const`의 중요성은 매우 커집니다.

`function argument`로 쓰인 `variable`이 `function call` 이후 값이 바뀔 가능성이 생겼거든요.   
(`function parameter`가 `reference type`일 때에 말입니다.)

`variable`을 `write`하는 게 의도치 않은 `side effect`일 경우,   
그 `function call`이 직접적인 원인임을 발견하기가 매우 어렵습니다.

```cpp
std::string msg = "Hello, World!\n";
dosomething(msg);

/// ...

std::cout << msg
```

위 코드의 출력 결과가 `Hello, World!\n`가 아니었을 때,    
`dosomething`이 원인임을 발견하기가 어렵다니깐요?

그래서 일반적으로 `C++` 프로그래머들은   
`write` 동작이 있을 `variable`은 반드시 `non-const`로,   
`read-only`일 `variable`은 반드시 `const`로 `declare`합니다.

이분법적이죠.

`C++`을 할 줄 아는 프로그래머의 `code`를 봤을 때,   
`const`가 붙어있지 않은 `variable`을 봤다면   
반드시 그 `variable`을 `write`할 것이라 예상해도 무방합니다.

- volatile

`volatile`은 `compiler`의 `optimization(최적화)` 대상이 아님을 나타낼 때 쓰입니다.   

원하지 않는 `optimization`로 인해 예상과는 `code`가 다르게 작동하는 등의 이유로,   
강제로 `optimization`를 막아야 할 때가 있습니다.   

매우 드문 경우이기 때문에,   
마주칠 일은 별로 없습니다.

```cpp
#include <iostream>

int main() {
    const int num = 10;
    *const_cast<int*>(&num) = 20;
    
    std::cout << "num = " << num << '\n';       // output: 10
    std::cout << "*&num = " << *&num << '\n';   // output: 20

    return 0;
}
```

`const_cast`라는 영문 모를 것이 튀어나오긴 했지만,   
`code`를 살펴보면 대충 짐작이 가실 겁니다.

`pointer/reference to constant`를 `pointer/reference to non-constant`로 바꿔주는 `casting`이죠.   
`pointer/reference`가 가리키는 `data type`의 `const qualification`을 제거합니다.

문제는 말입니다.

`compiler`는 `num`이 `const int`로 `declare`된 것을 보았고,   
`initialization`에 `integer literal`인 10이 쓰인 것도 보았습니다.   
(`literal`은 이름(`identifier`)을 통해 메모리에 `access`할 필요 없이,    
`code` 상에 직접적으로 나타나는 값을 의미합니다.    
"이 데이터는 이름이 아니라 문자 그대로의 값이다." 라는 의미에서 `literal`이라는 이름이 붙었죠.)

따라서 `compiler`는 `num`의 값이 언제나 10일 것이라 추측하는 것이 합리적입니다.   
그렇다면 굳이 매번 `num`의 메모리에 `access`해서 10이란 값을 꺼내오는 것보다,   
`code`의 `num` 자체를 10으로 치환해버리는 게 메모리 `access`가 없어서 효율적입니다.

이것은 `constant propagation`라고 불리는 `compiler optimization`입니다.    
`object code` 상에서 `num`을 `read`하는 부분마다 `num` 대신 10을 `immediate operand`로 박아버리죠.

그러나 `num`은 물리적으로 `constant`가 아니었습니다.   
`const_cast`에 의해서 값이 20으로 바뀌어버렸죠.

그렇다면 `num`을 출력했을 때 20이 출력되어야 할 겁니다.   
하지만 `compiler`가 첫 번째 출력문을 `optimize`해서

```cpp
std::cout << "num = " << 10 << '\n';
```

으로 바꿔놓은 상태이기 때문에, 바뀐 `num` 값은 출력에 반영되지 않습니다.

반면, 밑의 코드의 경우에는   
`num`에 대해 `memory address`를 취하고 `dereference`하기 때문에,   
`num`을 10으로 치환해버릴 수가 없습니다.

10은 `literal`이기 때문에 `memory address`를 취하는 것이 불가능하거든요.   
`&10`과 같은 코드는 보기에도 괴상하지 않나요?

따라서 20으로 값이 바뀐 `num`을 온전히 출력합니다.

`num`과 `*&num`이 다른 값을 출력한다니, 기괴하죠?

실제로 볼 일이 전혀 없는 예시를 들긴 했지만,   
`volatile`이 등장하는 국면은 굉장히 미묘하고 어렵기 때문에   
이러한 예시를 들어야만 했습니다. 이해해주세요.

`volatile`을 이용하면 이제 위 `code`는 합리적으로 동작합니다.

```cpp
#include <iostream>

int main() {
    const volatile int num = 10;
    *const_cast<int*>(&num) = 20;
    
    std::cout << "num = " << num << '\n';       // output: 20
    std::cout << "*&num = " << *&num << '\n';   // output: 20

    return 0;
}
```


- restrict

`restrict`는 특정 `memory address`에 `access`하는 유일한 `pointer`를 나타낼 때 쓰입니다.   

```cpp
int* restrict resptr = (int*)malloc(sizeof(int)*10);
```

위의 `code`의 경우 `(int*)malloc(sizeof(int)*10);`로 얻어진 `memory address`에 `access`하기 위해서는   
오로지 `resptr`라는 `pointer`만 사용할 수 있습니다.

같은 `memory address`를 담는 `pointer`를 만드는 순간 `restrict qualification`은 위반됩니다.

`compiler`의 `optimization`에 도움을 준다고 하네요.

`code`가 되게 `C` 냄새가 풀풀 나죠?  

그렇습니다.   
`restrict`는 `C99`에서 넘어온 `keyword`입니다.

그래서인지 표준 `header`인 `<type_traits>`에서는   
`remove_const`, `remove_volatile`, `remove_cv`는 있는 반면 `remove_restrict`는 없습니다.

그렇다고 `C++` 세상에서 쓰는 것만도 못한 물건이라고 함부로 치부하기에는 두렵네요.   
뭐든지 쓰임이 있을 테니까요.

## 타입 한정사가 포인터와 엮이는 경우

`pointer`는 `qualifier`가 쓰일 수 있는 위치가 두 개입니다.   
어디에 `qualifier`가 붙느냐에 따라 의미가 달라지죠.
  
`pointer`는 사실상 신경써야 하는 `data type`이 두 개이기 때문입니다.

- `pointer` 자체의 `type`
- `pointer`가 가리키는 `object`의 `type`

이렇게 말이죠.

이제 추측하실 수 있겠지만,  
`qualifier`의 위치는 다음 두 경우중 어떤 경우냐에 따라 달라집니다.

- `pointer` 자체의 `type`에 `qualification`을 부여하는 경우
- `pointer`가 가리키는 `object`의 `type`에 `qualification`을 부여하는 경우

```cpp
int n = 0;
int m = 1;

int* p2i = &n;                  // pointer to int
const int* p2ci = &n;           // pointer to const int
int* const cp2i = &n;           // const pointer to int
const int* const cp2ci = &n;    // const pointer to const int

p2i = &m;
*p2i = n;

p2ci = &m;
//*p2ci = n;    // error: writing const value

//cp2i = &m;    // error: writing const pointer
*cp2i = n;

//cp2ci = &m;   // error: writing const pointer
//*cp2ci = n;   // error: writing const value

volatile int* p2vi = &m;
int* volatile vp2i = &m;
volatile int* volatile vp2vi = &m;

const volatile int* const volatile cvp2cvi = &m;
```

많이들 헷갈려 하는 부분입니다.   
`qualifier`가 앞에 붙으면 `referencing data type`의 `qualification`을,   
뒤에 붙으면 `pointer`의 `qualification`을 나타냅니다.

`qualified pointer`를 사용할 일은 거의 없습니다.   
그러나 사용할 일이 없어도 알아야 되는 개념이 있고, 사용할 일이 없어서 몰라도 되는 개념이 있죠.

`qualified pointer`는 사용할 일이 없어도 알아야 되는 개념에 속합니다.   
여러분도 모르게 `qualified pointer`를 사용하게 될 때가 존재하고,   
(`object`가 `const`여서 모든 `data member`에 `const`가 붙는데   
`data member` 중에 `pointer`가 있었을 경우 등)   
`pointer`에 대한 이해에 조금이나마 도움도 되고,    
어쨌든 사용하게 되었다면 그 이유는 반드시 원하는대로 동작하는 `code`를 작성하기 위해서거든요.

>같은 `pointer`에 대한 `dereference`들은 `dereference`로 얻어진 값을   
>`temporary variable`에 저장함으로써 `optimize`되는 경우가 있습니다.   
>
>어차피 같은 값일 것이라 추론되면, 무의미한 `dereference operation`을 줄이는 것이죠.
>
>그런데 만약에 해당 `pointer`가 `interrupt`나 다른 `thread`에 의해 `write`된다면?   
>`compiler`가 섣불리 추론한 것과 달리 `dereference`로 얻어진 값들이 같은 값이 아닙니다!
>
>`compiler`가 `temporary variable`에 저장한 값이 실제 필요한 값과 달라져버렸습니다.
>
>`pointer`의 `data type`이 `T*`였다면
>`const T* volatile`를 꺼내들 수 밖에 없는 순간이 온 것이죠.   

정말 미묘하지만, 가벼이 여길 주제는 아닙니다.

## 타입 한정사가 레퍼런스와 엮이는 경우

`reference`는 태생이 `pointer`이지만, `pointer`만큼 헷갈릴 구석은 없습니다.   

`pointer`는 `pointer` 자체의 상수성에 대해서 논해야 했지만,   
`reference`는 그런 걸 논할 필요가 없거든요.  

`reference` 자체는 `const`나 `volatile`이 될 수 없습니다.

> For any type T (including incomplete types), **other than function type or**   
> **reference type,** there are three more distinct types in the C++ type system:   
> const-qualified T, volatile-qualified T, and const-volatile-qualified T.   
> \- source: cppreference

`initialization` 이후의 `reference`에 대한 `access`는 자동으로 `dereference`된다고 했죠.

이 점이 많은 고민을 사라지게 만듭니다.   

지난 과제에 있던 문장이죠.

>한번 `initalize`되면, 참조하는 `memory address`를 바꿀 수 없습니다.

그런데 가만 보면, 이것이 `read-only`이고 `const`입니다.

그렇습니다.   
`reference`는 암묵적으로 `const`입니다.   

`volatile`의 경우는요?

왜 그런 결정을 내렸는지 합리적인 근거를 찾는 데에는 실패했지만,   
`reference`는 `volatile`이 될 수 없습니다.

어찌되었든, `reference`는 `pointer`처럼   
`qualifier` 위치에 따라 `qualification`의 의미가 달라지는 복잡한 상황에 엮이지 않습니다.   

그런데 참 어리석게도 동등한 의미를 지닌 표현이 여러 개일 수 있습니다.

```cpp
int n = 0;

int& rn = n;

const int& crn = n;
// int const& crn = n; // 위와 동등한 표현!

volatile int& vrn = n;
// int volatile& vrn = n; // 위와 동등한 표현!

const volatile int& cvrn = n;
// const int volatile& cvrn = n;
// volatile int const& cvrn = n;
// int volatile const& cvrn = n;
// int const volatile& cvrn = n;
```

## 참조 한정사

`ref-qualifier(참조 한정사)`는 `member function`의 `qualification`입니다.   
아마 여러분이 생각하신 것과 다를 수 있습니다.

**`reference`는 `data type`의 일부이지, `qualifier`가 아닙니다.**

`qualifier`의 특징에 대한 기억을 되살려볼까요?

>`qualifier`는 데이터가 차지하는 메모리의 크기에 영향을 미치지 않으며,   
>각각의 비트가 어떻게 해석되어 값을 결정하는지에도 영향을 미치지 않습니다.   
>즉, `qualifier`가 붙어있든 안 붙어있든 같은 `data type`을 위해 메모리에 저장되어있는 비트들은 정확히 같습니다.   

그리고 다시 `reference`를 살펴봅시다.

`int`와 `const int`는 똑같이 4바이트의 정수를 저장합니다.   
이들의 메모리 상에 있는 비트들은 정확히 같습니다.

`int`와 `int&`는 각각 4바이트의 정수와, 4/8바이트의 `memory address`를 저장합니다.   
`int&`는 `32-bit system`에선 4바이트, `64-bit system`에선 8바이트죠.

메모리 크기가 시스템에 따라 달라질 뿐더러,   
저장하는 값도 완전히 다릅니다.   

`data type`이 다르다는 말이죠.

`reference`가 `qualifier`인지 헷갈릴 때에는,

- `const int`와 `int`의 메모리
- `int`와 `int&`의 메모리

를 머릿속에서 비교해보세요.

<br>

`ref-qualifier`는 `member function` 뒤에 붙어서 해당 `member function`에 `qualification`을 부여합니다.

다음 항목에서 그 내용을 다뤄보죠.

## 멤버 함수 한정사

이 항목은 `class`에 대해서 알아야 온전히 이해할 수 있기 때문에,   
구체적인 `code`가 등장하는 부분은 후에 `member function`에 대한 개념을 확립하고 나서   
다시 읽어보시기 바랍니다.

`member functon`을 특정한 `data type`의 `object`에 대해서만 `call`할 수 있게 만듭니다.   
`object`의 `data type`을 `filter`하는 것이죠.

`const member function`은 `object`가 `const`였을 경우에만(즉, `*this`가 `const`였다면) `call`할 수 있습니다.

```cpp
class Foo
{
public:
    int& get()
    {
        return data;
    }

    const int& get() const
    {
        return data;
    }

private:
    int data;
};
```

`member variable`에 대한 `access`를 제공할 때,   
`const member function`과 `non-const member function`을 나눠서 만드는 일이 흔합니다.

`const member function`은 `const reference`를 `return`하고    
`non-const member function`은 `non-const reference`를 `return`하죠.

```cpp
// int& Foo::get()을 호출합니다.
Foo bar;
bar.get() = 2;

// const int& Foo::get() const를 호출합니다.
const Foo cbar;
// cbar.get() = 2;  // error: const int를 write하고 있습니다.
```

잠깐 중요한 부분을 짚고 넘어가봅시다.

`bar`가 `non-const`일 때에는 당연히 `const int& Foo::get() const`의 `filter`를 통과하지 못하므로   
`int& Foo::get()`이 `call`되지만,   

`bar`가 `const`일 때에는 `const int& Foo::get() const`와 `int& Foo::get()` 둘 다 `call`될 수 있죠.

이럴 때에 `compiler`는 "딱 맞는 퍼즐"을 사용합니다.   

`const int& Foo::get() const`는 `const Foo`에 대해서만 `call` 가능하고,   
`int& Foo::get()`은 `Foo`와 `const Foo`에서 `call` 가능합니다.   
`compiler`는 애매하게 맞는 퍼즐인 `int& Foo::get()`보다는   
딱 맞는 퍼즐인 `const int& Foo::get() const`를 선택합니다.

일반적인 것과 특수한 것이 충돌할 때에, 특수한 것을 선택하는 전략이죠.   
똑같이 조건을 100% 만족한다면 조건 개수가 더 많았던 쪽을 선택합니다.

후에 `function overloading`이나 `template`을 다룰 때에 이러한 `compiler`의 전략을 아는 게   
굉장한 도움이 될 것입니다.

<br>

`const-qualified member function`을 만들 수 있는 것처럼,   
`volatile-qualified member function`을 만들 수 있고   
`ref-qualified member function`을 만들 수 있습니다.

서로 다른 `qualifier`들이 결합되어 복합적인 `qualification`을 나타낼 수도 있습니다.

어찌되었건, `member function`에 붙는 `qualifier`들은   
특정하게 `qualify`된 `object`들만이 해당 `member function`을 `call`할 수 있도록 합니다.

`type qualifier`의 경우 `reference`는 `qualifier`가 아니었는데요.   
`member function qualifier`의 경우 `ref-qualifier`라는 것이 존재합니다.

```cpp
class Foo
{
public:
    void bar() & { ... };
    void qux() && { ... };
    void corge() { ... };

    ...
};
```

`Foo::bar`는 `l-value object`만이 `call`할 수 있고,   
`Foo::qux`는 `r-value object`만이 `call`할 수 있습니다.   

`data type`이 `reference`임을 나타낼 때 붙는 `&`는   
`data type`이 비트들을 어떻게 저장하는지에 지대한 영향을 끼치지만,   
`member function`을 `qualify`하는 데 쓰이는 `&`는   
`*this`의 저장에도, `member function`의 저장에도, `parameter`등의 저장에도 아무런 영향을 끼치지 않습니다.

그래서 `data type`의 일부인 `reference`는 `qualifier`가 아니지만,   
`member function`에 붙는 `&`는 `qualifier`인 겁니다.   
`ref-qualifier`라고 불리죠.

`STL container`나 `heap memory`를 얻어온 `pointer`와 같이   

- 겉보기 `memory size`와 실제로 `allocate`한 `memory size`가 다른 `data type`

을 `member variable`로 가질 경우 `ref-qualifier`가 유용할 수 있습니다.   
그런 경우에 `r-value` `object`의 `member function call`에서 `deep copy`를 이용하는 부분들은   
`shallow copy(move)`를 이용하도록 `optimize`할 수 있거든요.

```cpp
class Foo { ... };

class Widget
{
public:
    Foo& bar() & { ... };
    const Foo& bar() const& { ... };
    Foo&& bar() && { ... };

    ...
};
```

이런 `code`를 작성하게 될 수도 있습니다.

## static 키워드

`static(정적인)`이란 말은 `dynamic(동적인)`의 반대말이죠.    

`static`은 `life cycle(생존 주기)`이 `process`와 같은 것들에 붙는 `keyword`입니다.

`static variable`은 `process` 내내 메모리를 차지하고 있는 `variable`입니다.

`global variable`의 경우 기본적으로 `static`인데,   
`global variable`은 `code`의 어디에서든 `access`가 가능하기 때문에   
함부로 사용할 수가 없습니다.   

`global variable`과 관련하여 무엇인가 문제가 발생했을 때,   
모든 `code`를 점검해야 하니까요.   
(의도치 않은 결과를 야기한 것을 `side effect`라고 하는데,   
모든 `code`가 `side effect`의 용의자가 됩니다.)

그래서 `local variable`이나 `member variable`에 `static`을 붙여,   
`access`는 제한하되 `life cycle`은 `global variable`와 같도록 할 수 있습니다.   

`variable`에 붙는 `static`은 `life cycle`에만 변화를 준다는 말이기도 하죠.

<br>

`static variable`이 등장하는 국면은 보통 두 가지입니다.

- 개별 `object`나 개별 `function call`이 데이터를 공유해야 할 때

  - `static member variable`은 `class`에 `bind`되어,   
  모든 `object`들이 해당 `member variable`을 공유합니다.   
  `object`에 `bind`된 것이 아니기 때문에,   
  `object`의 개수에 상관 없이 `static member variable`은 한 개이지요.   
  해당 `class`를 대표하는 `variable`이라고 할 수 있겠습니다.
  - `static local variable`은 `function call`과 독립되어,   
  최초 한 번만 `initalizer`가 실행됩니다.   
  같은 `argument`로 `call`했더라도 시점에 따라서 다른 결과가 `return`될 수 있으며,   
  이전의 실행 결과가 저장되는, 일종의 "상태"가 되는 셈입니다.

<br>

한편, `static`은 `member function`에도 붙을 수 있습니다.   

`C++`에서 `member function`은 어차피 `class`에 `bind`되어 `static`하게 메모리에 존재합니다.   
따라서 `static`이라는 `keyword`와 `life cycle`의 연관성은 `member function`의 영역에 오는 순간 사라져버리죠.

그런데 왜 여전히 `static`이라는 `keyword`가 유효할까요?

그 근거로는 `global variable` 대신 `static variable`을 이용했던 이유가 하나,   
`access specifier`의 영향이 하나로 총 두 개의 근거가 있습니다.

- `global access`가 가능함으로 인한 `side effect`의 위험을 피하기 위해서
- `private static member variable`에 `access`하기 위해서


다음의 세 개에 대해 예제 코드 추가하기
1. `static local variable`
2. `static member variable`
3. `static member function`

## TODO

## Reference

- [\[Stack Overflow\] what is the meaning of "qualifier"?](https://stackoverflow.com/questions/3785789/what-is-the-meaning-of-qualifier)   
- [\[cppreference\] cv (const and volatile) type qualifiers](https://en.cppreference.com/w/cpp/language/cv)   
- [\[cppreference\] const type qualifier](https://en.cppreference.com/w/c/language/const)   
- [\[cppreference\] volatile type qualifier](https://en.cppreference.com/w/c/language/volatile)   
- [\[cppreference\] restrict type qualifier](https://en.cppreference.com/w/c/language/restrict)
- [\[cppreference\] Non-static member functions](https://en.cppreference.com/w/cpp/language/member_functions)
- [\[geeksforgeeks.org\] constant propagation in compiler design](https://www.geeksforgeeks.org/constant-propagation-in-complier-design/)