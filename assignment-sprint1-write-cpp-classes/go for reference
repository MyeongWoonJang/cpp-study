## 레퍼런스 소개

`reference(참조자)`는 자동으로 `dereference(역참조)`되는 `pointer`입니다.

여러분의 코드에서 난잡한 `&(addressof operator)`, `*(dereference operator)`를 지워버릴 도구죠.   

다른 `function scope`의 메모리를 참조하는 게 `pointer`의 주된 용도입니다.   
(`memory access`를 `run time` 정보에 따라 다르게 구현할 때에도 쓰입니다.)   
(`scope`는 범위 혹은 유효 범위라는 뜻으로, `C++` `code` 상에서   
어떠한 `identifier(식별자, 예를 들어 변수나 함수의 이름)`의 `access` 가능 지역을    
제한하는 모든 종류의 양식을 가리킵니다.   
`{ }` 기호를 통해 나타내며, 흔히들 말하는 `지역`이라는 개념을 포함합니다.)

`reference`는 `pointer`를 이용해 구현되는 만큼 용도도 비슷합니다.   

여전히 다른 `function scope`의 메모리를 참조하는 게 `reference`의 주된 용도이지요.

## 포인터와 레퍼런스의 차이

`reference`는 이렇게 이용합니다.

```cpp
void inc_one(int& num)
{
    ++num;
}

int main()
{
    int n = 99;
    inc_one(n);

    std::cout << n;     // 100이 출력됩니다.
}
```

위 `code`는 `pointer`를 이용했다면 다음과 같이 구현됩니다.

```cpp
void inc_one(int* num)
{
    ++*num;
}

int main()
{
    int n = 99;
    inc_one(&n);

    std::cout << *n;    // 100이 출력됩니다.
}
```

다시 위를 살펴보세요.   
`pointer` 버전에서 발견된 `*`, `&`가 `reference` 버전에서는 존재하지 않습니다.   

`pointer`와 구별되는 `reference`의 원리를 설명하기 전에,   
다음과 같은 코드는 분명 여러분이 원하는대로 동작하지 않을 것이란 걸 알고 넘어갑시다.

```cpp
void inc_one(int num)       // 포인터도 아니고, 레퍼런스도 아닙니다.
{
    ++num;
}

int main()
{
    int n = 99;
    inc_one(n);

    std::cout << n;     // 99가 출력됩니다.
}
```

`function`은 다른 `function scope`의 `variable`을 `access`할 수 없습니다.   
오로지 자신의 `local variable`과 `global variable`만 `access` 가능하죠.   

**`function`의 `parameter`는 전부 `argument`의 사본으로 `initialize`됩니다.**   
**이 명제는 항상 참이니 명심하세요.**

`pointer`나 `reference`가 다른 `function scope`의 메모리를 참조할 수 있는 것은,   
원본 `variable`에 대한 `access` 권한이 있기 때문이 아니라,   
원본 `variable`의 `memory address` 사본을 저장하기 때문입니다.   

`value`의 사본을 받아오면(`pass-by-value`) 사본을 아무리 `write`해봐야 원본은 그대로입니다.   
`memory address`의 사본을 받아오는 경우도(`pass-by-reference`) `memory address` 자체는 사본입니다.   
그러나 그 `memory address`에 담긴 `value`는 원본이죠.   

집을 복사하냐, 집 주소를 복사하냐의 문제입니다.  
집을 복사하면 집이 두 개가 되는데,   
집 주소는 복사해봐야 집이 하나죠.   

<br>

자 이제, `pointer`와 구별되는 `reference`의 원리를 알아봅시다.

## 레퍼런스의 특성

## TODO

## Reference