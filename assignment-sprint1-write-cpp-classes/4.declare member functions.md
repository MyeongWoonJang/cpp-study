## 멤버 함수 선언

프로그램은 `OOP` 문법에 의해, `object`들을 생성하고 각 `object`들이 자신만의 `behaviour`를 수행하며 상호작용하는 과정으로 기술될 수 있다고 했죠.   

`C++`에서 `object`의 `behavior`는 `member function(멤버 함수)`으로 구현됩니다.

`class` 내부에서 작성된 `function`은 그 `class`의 `object`를 통해 동작하는 `member function`이 됩니다.

```cpp
class Foo
{
public:
    void bar();     // public member function declaration

private:
    void qux();     // private member function declaration
};

void corge();   // non-member function declaration
```

`member function`과 `non-member function(global function)`의 차이점은    
- `member function`은 `class` 내에서 `declare`되고,   
  `non-member function`은 `class` 밖에서 `declare`됩니다.
- `member function`은 `object`를 통해 `call`되고,   
  `non-member function`은 `global`하게 `call`됩니다.

```cpp
Foo a;      // Foo는 클래스, a는 객체입니다.
a.bar();    // member function call
            // 객체에 .을 적어 멤버임을 나타냅니다.

corge();    // non-member function call
            // 비멤버 함수는 객체가 필요 없습니다.
```

## 함수 선언 작성

`function declaration`을 작성해야 `compiler`에게 해당 `function`의 존재를 알릴 수 있습니다.

`compiler`가 `function call`을 보았을 때, 어느 부분에 가야 해당 `function`이 있는지 알 수 있는 힌트가 되죠.

`function declaration`은 다음의 세 가지를 밝힙니다.

- `return type(반환 타입)`
- `name of function(함수의 이름)`
- `parameter type(매개변수 타입)`

```cpp
return_type name_of_function(parameter_type1 foo, parameter_type2 bar);     // 이와 같은 형태로 작성됩니다.

int add(int lhs, int rhs);      // return type: int
                                // name of function : add
                                // parameter type1 : int
                                // parameter type2 : int
```

`foo`와 `bar`, `lhs(left hand side)`와 `rhs(right hand side)`은 `parameter`의 이름입니다.   
`function declaration`에 필수는 아니지만, 보통 적는 편입니다.   

`return type`과 `parameter type`을 합쳐서 `function signature(함수 서명)`이라고 부르는데요.

필요한 함수를 잘 작성하려면

- `function signature`를 잘 구상해야 합니다.

  - 어떤 `parameter`를 전달받아서(입력), 어떤 `return value`를 돌려줘야하는지 생각해야겠죠(출력).

- `function`이 어떤 기능을 하는지 이름만 보면 알 수 있도록 직관적인 이름을 잘 짓는 것도 중요합니다.

위에 적힌 `add`의 경우 두 `int` 값을 `parameter`로 받아 `int` 값을 `return`합니다.

우리의 직관에 의하면, `parameter`에 전달되는 두 `int`값을 더한 결과가 `return`될 것이라고 추측됩니다.

이런 게 좋은 `function declaration`의 효과입니다.

## 멤버 접근

`C++`에서는 `.`을 적어서 특정한 `object`의 `member`에 `access`할 수 있습니다.   

폴더 정리와 비슷하다고 생각할 수 있습니다.   
여러 폴더 안에 파일을 나누어 정리하면, 원하는 파일 찾기가 쉬워집니다.   

폴더는 `C:/users/user/desktop`처럼 `/`를 통해 하위 폴더나 파일에 `access`하죠.   
그 `/`가 `.`로 바뀌었다고 생각하면 편합니다.

실제로 객체 안에 객체가 있는 복잡한 경우도 이와 같이 생각하면
```cpp
foo.bar.qux.corge.dosomething();
```
간단하게 느껴지죠?

## 함수 오버로딩

`C++`에서는 같은 이름으로 서로 다른 `function`을 선언할 수 있습니다.   
대신, `parameter`가 달라야 합니다.

이를 `function overloading(함수 중복 정의)`라 합니다.

이름만 같고 `parameter`가 다른 `function`들은,   
`compiler`가 자동으로 어떤 `function`을 `call`해야 하는지 판별합니다.

비슷한 종류의 동작이라면 같은 이름을 사용해서,  
개발자가 많은 양의 `function` 이름을 외워야 하는 부담을 줄일 수 있습니다.

예를 들어,
```cpp
int add(int, int);
float add(float, float);
double add(double, double);
```
과 같은 케이스가 있을 수 있습니다.

<br>

`member function`의 경우엔 특별한 `overloading` 방법이 존재합니다.

```cpp
class Foo
{
public:
    int& bar();
    const int bar() const;  // const overloading

private:
}
```

`function declaration`의 끝부분에 `const(constant, 읽기 전용)`를 적으면,   
객체가 `const` 객체였을 경우에 대한 `overloading`이 됩니다.

```cpp
Foo nc;
const Foo c;

nc.bar();   // int& bar()가 호출됩니다.
c.bar();    // const int bar() const가 호출됩니다.
```

`const` 객체는 대입 연산이 불가능합니다.   
대입 연산은 `write` 동작이기 때문이죠.

`const` 객체는 `const member function`만 `call`할 수 있습니다.   
그리고 `const member function`에 `write` 동작이 존재한다면, `compile error`가 발생합니다.   
좋은 안전장치죠.

## TODO

- [X] my_unique_ptr.h에 멤버 함수 선언하기

  - `my_unique_ptr`는 `pointer`를 관리하는 `class`로,   
  `get`이라는 `member function`를 통해 `my_unique_ptr`가 관리하는 `class`를 얻을 수 있습니다.
  - 후에 `templatize` 되겠지만, 일단 지금은 `my_unique_ptr`가 관리하는 `pointer`는 `int*`라고 가정합니다.
  - `get`을 위한 적절한 `function declaration`을 만들어보세요.
  - `const overloading`도 필수입니다.

- [X] my_shared_ptr.h에 멤버 함수 선언하기

  - `my_shared_ptr`는 `pointer`를 관리하는 `class`로,   
  `get`이라는 `member function`를 통해 `my_shared_ptr`가 관리하는 `class`를 얻을 수 있습니다.
  - 후에 `templatize` 되겠지만, 일단 지금은 `my_shared_ptr`가 관리하는 `pointer`는 `int*`라고 가정합니다.
  - `get`을 위한 적절한 `function declaration`을 만들어보세요.
  - `const overloading`도 필수입니다.

- [X] my_string.h에 멤버 함수 선언하기

  - `my_string`은 문자열(`char*`)을 관리하는 `class`입니다.

- [X] vec.h에 멤버 함수 선언하기
- [X] mat.h에 멤버 함수 선언하기

## Reference