## 동적 할당과 반납

앞선 과제를 통해 `process`의 메모리 구조에 대한 이해가 생겼을 것입니다.   

`dynamic allocation`은 `process`가 이미 한창 `run` 중인, `run time`에 메모리를 `allocate`하는 것을 말합니다.   
그 외의 모든 `allocation`은 `process`가 `run`되어 메모리에 적재되는 처음 한 순간에만 일어납니다.

다음의 경우에 `dynamic allocation`이 유용할 수 있습니다.
- `run time` 의존적인 데이터에 의해 필요한 메모리 크기가 정해질 경우

  - 사용자의 입력은 `run time`에 얻어지는 데이터입니다.
  - 시간은 `run time` 내내 변화하는 데이터입니다.
  - 파일 데이터는 `run time`에 읽어 와야 이용할 수 있는 데이터입니다.
  - 네트워크 패킷은 `run time`에 읽어 와야 이용할 수 있는 데이터입니다.

- `process`의 `run time` 길이에 비해, 실제 메모리가 필요한 시간은 그리 길지 않은 경우

  - 게임의 스타트 씬에선, 엔딩 씬에 필요한 데이터를 위해 메모리를 확보하지 않습니다.
  - `deep neural network`로 이미지를 분류하는 일엔 거대한 텐서들이 필요하지만,   
  분류된 이미지를 정리하고 표시하는 데에는 거대한 텐서들이 필요하지 않습니다.

- 필요한 메모리의 크기가 큰 경우
  
  - `stack` 메모리는 연속된 메모리 배치를 요구하고 `static`하게 `allocate`되는 만큼,   
  작은 크기로 설정하는 게 일반적입니다.
  - `heap` 메모리는 메모리 배치가 연속적이지 않아도 괜찮고,   
  필요할 때 `allocate`하고 필요없으면 `deallocate`하는 `free memory`입니다.

## heap 메모리 참조

앞선 과제에서, `dynamically allocated memory`는 `variable` 문법으로 다루기 부적절하다고 했습니다.

`variable`은 그 `declaration`이 포함된 `scope`에서 유효합니다.   
`static variable`은 `static`하게 존재해야 하고, `local variable`은 `function`과 생존 주기를 함께합니다.

한 `function`이 한창 실행 중일 때 `allocation`과 `deallocation`이 일어나거나,   
한 `function`에서 `allocate`된 메모리가 다른 `function`에서 `deallocate`되는 일은 `variable` 문법으론 힘듭니다.

`variable` 문법은, `stack` 메모리 관리에 초점이 맞춰져 있지요.

그럼, 어떻게 `dynamically allocated memory`를 다루나요?   
실제 `process`가 확보할 `memory address`가 어떤 값일지 모르니 `variable`을 쓰는 것이기도 한데 말이에요.

`pointer`를 이용하면 됩니다.

`pointer`는 `memory address`를 저장하는 `variable`이죠.   
`pointer`가 `heap memory`에서 원하는 부분의 `memory address`를 저장하도록 하면 됩니다.   

`pointer`가 저장하는 `memory address`에 언제 `allocation`과 `deallocation`이 일어나는지는 `pointer`의 관심사가 아닙니다.   
단지 `memory address`를 저장할 뿐이죠.

`pointer`가 `scope`를 벗어난다 해도, `pointer`가 저장하던 `memory address` 값을 잃는 것이지,   
그 `memory address`에 `allocate` 되었는지 안 되었는지도 모르는 실제 메모리가 `deallocate`되진 않습니다.

<div align="center"><image src="https://user-images.githubusercontent.com/73771162/198875574-4958d4cc-fa9b-43f3-aa2a-ae4c36227e58.png"></div>

`variable` 자체가 특정한 `memory address`에 쉽게 `access`하기 위한 도구인데,   
그 `variable`이 저장하는 값도 `memory address`이니 복잡하게 느껴지실 겁니다.

`pointer`는 `scope` 바깥의 `memory`를 `access`하는 용도로 쓰입니다.

`function`에 `argument`로 전달되어 서로 다른 `function`이 서로의 메모리를 `access`하도록 하는 데에도 쓰이지만,   
이처럼 `heap memory`를 `access`하는 데에도 쓰입니다.

## TODO

## Reference