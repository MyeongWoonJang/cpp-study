## 멤버 함수 정의

`OOP`에서 `object`의 `behaviour`는 `member function`으로 구현됩니다.

`member function declaration` 과제에서 `object`가 어떤 `behaviour`를 가지도록 할까 구상하며   
`function declaration`을 작성했었죠.

`function definition`을 작성하면서는, 구상이 아니라 구현을 하게 됩니다.   
실제로 `behaviour`의 구체적인 내용을 작성해보고,   
더 나은 설계와 동작을 고민해보며 `member function`과 `member variable`을 수정해야합니다.   

필요에 따라 기존의 `declration`을 수정하거나 제거할 수 있으며,   
이미 완성한 `function definition`을 재작성할 수도 있습니다.   

## 멤버 접근과 캡슐화

`make class outline` 과제에서 `access specifier`를 공부하셨을 겁니다.   
그러나 지금까지 실제로 `member access`를 해본 적은 없죠.   

그래서 다시 한번 짚으려고 합니다.

- `public` 영역의 `member`는 그 `member`가 속한 `class scope` 외부에서도 `access`가 가능합니다.
- `private` 영역의 `member`는 그 `member`가 속한 `class scope` 내부에서만 `access`가 가능합니다.

```cpp
class Foo
{       // class scope begin
public:
    void member_function(int a, int b, int c)
    {
        var1 = a;
        var2 = b;
        var3 = c;
    }

    int var1;

private:
    int var2;   // private 영역의 member는 그 member가 속한
    int var3;   // class scope 내부에서만 access가 가능합니다.
};      // class scope end

int main()
{
    Foo obj1;

    obj1.var1 = 1;      // okay, var1는 public 영역에 있습니다.
    // obj1.var2 = 2;   // error! var2는 private 영역에 있습니다.
    // obj1.var3 = 3;   // error! var3는 private 영역에 있습니다.

    obj1.member_function(1, 2, 3);  // okay, member_function은 public 영역에 있습니다.
}
```

`public` 영역의 `member function`이 `private` `member variable`을 `access`하는 걸 주의깊게 보십시오.

두 가지 중요한 점이 있습니다.

- `member function`은 `class scope` 내부에 있기 때문에 `private member`에 얼마든지 `access`가 가능합니다.   
반면 `main`은 `class scope` 외부이기 때문에 `Foo`의 `private member`에 `access`할 수 없죠.  
- `member function`은 `object`에 `.`을 찍는 방법으로 `member access`를 하지 않습니다.   
`object` 명시를 생략하고 `member access`를 하면,   
자신을 `call`한 `object`에 대한 `member`인 것으로 추론됩니다.

<br>

`public member`인 `member function`을 `call`하는 것으로,   
**간접적으로 `private member`에 `access`하고 있습니다.**

대부분의 `class`들이 이렇게 설계됩니다.

`private` 영역에 중요한 `data`나 복잡한 `internal logic`을 꽁꽁 숨겨놓고,   
`public` 영역에는 쉽고 `abstraction(추상화)`이 이루어진 `member function`을 위치시킵니다.

**이것을 `encapsulation(캡슐화)`이라고 합니다.**   

직관적이고 요약된 `member`들을 이용하는 것으로   
동작 구현, 결과 예측, 유지 보수를 매우 경제적으로 할 수 있게 됩니다. 

<br>

`abstraction`에 대한 설명은 잠시 건너뛰었는데,

>직관적이고 요약된, `member`들을 이용하는 것으로

이 부분이 `abstraction`을 표현하는 내용입니다.   

기계어에 가깝고 복잡할수록 `abstraction level(추상화 수준)`이 낮고,   
사람의 언어에 가깝고 직관적일수록 `abstraction level`이 높다고 말합니다.

구체적인 내용을 알 필요 없이,   
첫 눈길에 아! 할 수 있도록 구성하는 것, 그것이 `abstraction`입니다.

<br>

만약 `encapsulation`과 `abstraction`이라는 개념으로 머리가 지끈거리신다면,   
일단은 `member function`을 `public` 영역에 두고,   
`member variable`을 `private` 영역에 두는 것부터 시작해보세요.

## TODO

```cpp
class Foo
{
public:
    void bar();     // member function declaration
};

void Foo::bar()     // member function definition
{
    std::cout << "Hello, World!\n";
}
```

`function declaration`은 보통 `.h` 파일에,   
`function definition`은 보통 `.cpp` 파일에 둡니다.

`class scope` 바깥에서 `function definition`을 작성할 때는,   
`class scope`를 따로 표기해 주어야 합니다.   
(`Foo::`는 `Foo`라는 `class scope` 안에 있다는 것을 나타냅니다.   
`std::`가 `std`라는 `namespace scope` 안에 있다는 것을 나타내는 것처럼요.)

이 표시가 없으면, `compiler`는 `global function`을 `define`하는 줄로 알 겁니다.   
따라서 `member function`을 `define`할 때에는,   
`::` 기호로 어떤 `class scope`에 포함시킬지 나타내어 `member function`임을 명시해야 합니다.

`function definition`을 작성할 때에는,   
`function declaration`을 `copy&paste`한 뒤, `;`를 지우고 `::`, `{ }` 등의 `scope`를 표시하면 틀이 갖춰집니다.   

바로 위의 예시로 치면, `void bar();`를 `copy&paste`한 뒤 `;`를 지워 `void bar()`를 만들고,   
`Foo::`와 `{ }`의 `scope`를 표시해 간단하게 틀을 갖출 수 있습니다.

```cpp
void Foo::bar()
{

}
```

<br>

`Foo::`를 통해 해당 `function`이 `Foo`의 `member function`이라는 것을 나타냈으므로,   
**`class scope` 내에 `function definition`을 둔 것처럼 `private member access`를 할 수 있습니다.**

- [X] my_unique_ptr 멤버 함수 정의

    - `my_unique_ptr.h`를 참고하거나 필요하면 수정하며   
    `my_unique_ptr.cpp`에 `member function definition`을 작성해보세요.

        - [`declare member function`](https://github.com/Woon-2/cpp-study/blob/assignments-CS-1-CS-114/assignment-sprint1-write-cpp-classes/4.declare%20member%20functions.md) 과제에서 `member function`들의 설명을 참고하세요.   
        - `my_unique_ptr` `object`가 데이터를 얻고, 데이터를 잃는 동작을 구현해봅시다.
        - `my_unique_ptr`가 관리하는 `pointer` `object`를 `PO`라는 약칭으로 적도록 하겠습니다.

        ```cpp
        // my_unique_ptr가 데이터를 얻는 동작을 구현하는 함수를
        // construct라고 지었습니다.
        // 이 함수는 +2개의 오버로딩이 존재합니다.
        void my_unique_ptr::construct()
        {
            /* PO */ = nullptr;
        }

        void my_unique_ptr::construct(std::nullptr_t)
        {
            construct();
        }

        void my_unique_ptr::construct(int* const ptr)
        {
            /* PO */ = ptr;
        }

        // my_unique_ptr가 데이터를 잃는 동작을 구현하는 함수를
        // destruct라고 지었습니다.
        void my_unique_ptr::destruct()
        {
            delete release();
        }
        ```

        - 다른 `my_unique_ptr` `object`와 데이터를 교환하는 동작을 구현해봅시다.
  
        ```cpp
        void my_unique_ptr::swap(my_unique_ptr& other)
        {
            std::swap(/* PO */, other./* PO */);
        }
        ```

- [X] my_shared_ptr 멤버 함수 정의
- [X] my_string 멤버 함수 정의
- [X] vec 멤버 함수 정의
- [X] mat 멤버 함수 정의

## Reference