## 한정사

`qualifier(한정사)`는 `data type`에 대해 추가적인 정보를 제공해주는 `keyword`입니다.  

`qualifier`는 데이터가 차지하는 메모리의 크기에 영향을 미치지 않으며,   
각각의 비트가 어떻게 해석되어 값을 결정하는지에도 영향을 미치지 않습니다.   
즉, `qualifier`가 붙어있든 안 붙어있든 메모리에 저장되어있는 비트들은 정확히 같습니다.   

대신에 `compiler`가 `code`를 `compile`할 때,   
해당 데이터가 어떻게 `access` 되어야 하고 어디에 `store` 되어야 하는지 `qualifier`를 보고 분석합니다.   

이들은 언어로 치면 형용사와 비슷합니다:   
"a fickle man", "a volatile int", "an incorruptible lady", "a const double".

## 타입 한정사

`type qualifier`는 세 가지가 있습니다: `const`, `volatile`, `restrict`.   

자주 볼 가능성이 큰 순서입니다.   
`const`는 굉장히 자주 보겠지만, `restrict`는 그렇지 않겠죠.   

- const

여러분이 마주칠 99%의 `qualifier`는 `const`입니다.   
`constant(상수)`의 준말로, 변하지 않는 값 즉 `read-only value`임을 나타낼 때 쓰죠.

```cpp
int m = 2;
const int n = 3;

m = 5;
// n = 6;   const는 read-only!
```

`C++` 세상에 오는 순간 `const`의 중요성은 매우 커집니다.

`function argument`로 쓰인 `variable`이 `function call` 이후 값이 바뀔 가능성이 생겼거든요.   
(`function parameter`가 `reference type`일 때에 말입니다.)

`variable`의 값을 `write`하는 게 의도치 않은 `side effect`일 경우,   
그 `function call`이 직접적인 원인임을 발견하기가 매우 어렵습니다.

```cpp
std::string msg = "Hello, World!\n";
dosomething(msg);

/// ...

std::cout << msg
```

위 코드의 출력 결과가 `Hello, World!\n`가 아니었을 때,    
`dosomething`이 원인임을 발견하기가 어렵다니깐요?

그래서 일반적으로 `C++` 프로그래머들은   
`write` 동작이 있을 `variable`은 반드시 `non-const`로,   
`read-only`일 `variable`은 반드시 `const`로 이분합니다.

`C++`을 할 줄 아는 프로그래머의 `code`를 봤을 때,   
`const`가 붙어있지 않은 `variable`을 봤다면   
반드시 그 `variable`을 `write`할 것이라 예상해도 무방합니다.

- volatile

`volatile`은 `compiler`의 최적화 대상이 아님을 나타낼 때 쓰입니다.   

원하지 않는 최적화로 인해 예상과는 `code`가 다르게 작동하는 등의 이유로,   
강제로 최적화를 막아야 할 때가 있습니다.   

매우 드문 경우이기 때문에,   
마주칠 일은 별로 없습니다.

```cpp
#include <iostream>

int main() {
    const int num = 10;
    *const_cast<int*>(&num) = 20;
    
    std::cout << "num = " << num << '\n';       // output: 10
    std::cout << "*&num = " << *&num << '\n';   // output: 20

    return 0;
}
```

`const_cast`라는 영문 모를 것이 튀어나오긴 했지만,   
`code`를 살펴보면 대충 짐작이 가실 겁니다.

`pointer`가 가리키는 `type`에 대해 `const qualification`을 제거해   
`pointer`가 가리키는 `object`의 `write`가 가능하도록 해주는 `casting`이죠. 

문제는 말입니다.

`compiler`는 `num`이 `const int`로 `declare`된 것을 보았고,   
`initialization`에 `integer literal`인 10이 쓰인 것도 보았습니다.   

`constant propagation`라는 `compiler optimization`에 의해서   
`object code` 상에서 `num`의 값을 `read`하는 부분마다 `num` 대신 10을 `immediate operand`로 박아버리죠.

그러나 `num`은 물리적으로 `constant`가 아니었습니다.   
`const_cast`에 의해서 값이 20으로 바뀌어버렸죠.

그렇다면 `num`을 출력했을 때 20이 출력되는 것이 합리적입니다.   
하지만 `compiler`가 첫 번째 출력문을

```cpp
std::cout << "num = " << 10 << '\n';
```

으로 바꿔놓은 상태이기 때문에, 바뀐 `num` 값은 출력에 반영되지 않습니다.

반면, 밑의 코드의 경우에는   
`num`에 대해 `memory address`를 취하고 `dereference`하기 때문에,   
`num`을 10으로 치환해버릴 수가 없습니다.

10은 `literal`이기 때문에 `memory address`를 취하는 것이 불가능하거든요.

따라서 20으로 값이 바뀐 `num`을 온전히 출력합니다.

`num`과 `*&num`이 다른 값을 출력한다니, 기괴하죠?

실제로 볼 일이 전혀 없는 예시를 들긴 했지만,   
`volatile`이 등장하는 국면은 굉장히 미묘하고 어렵기 때문에   
이러한 예시를 들어야만 했습니다. 이해해주세요.

`volatile`을 이용하면 이제 위 `code`는 합리적으로 동작합니다.

```cpp
#include <iostream>

int main() {
    const volatile int num = 10;
    *const_cast<int*>(&num) = 20;
    
    std::cout << "num = " << num << '\n';       // output: 20
    std::cout << "*&num = " << *&num << '\n';   // output: 20

    return 0;
}
```


- restrict

`restrict`는 특정 `memory address`에 `access`하는 유일한 `pointer`를 나타낼 때 쓰입니다.   

```cpp
int* restrict resptr = (int*)malloc(sizeof(int)*10);
```

위의 `code`의 경우 `(int*)malloc(sizeof(int)*10);`로 얻어진 `memory address`에 `access`하기 위해서는   
오로지 `resptr`라는 `pointer`만 사용할 수 있습니다.

같은 `memory address`를 담는 `pointer`를 만드는 순간 `restrict qualification`은 위반됩니다.

`compiler`의 `optimization`에 도움을 준다고 하네요.

`code`가 되게 `C` 냄새가 풀풀 나죠?  

그렇습니다.   
`restrict`는 `C99`에서 넘어온 `keyword`입니다.

그래서인지 표준 `header`인 `<type_traits>`에서는   
`remove_const`, `remove_volatile`, `remove_cv`는 있는 반면 `remove_restrict`는 없습니다.

그렇다고 `C++` 세상에서 쓰는 것만도 못한 물건이라고 함부로 치부하기에는 두렵네요.   
뭐든지 쓰임이 있을 테니까요.

## 한정사가 포인터나 레퍼런스와 엮이는 경우

## 참조 한정사

## static 키워드

## TODO

## Reference

- [\[Stack Overflow\] what is the meaning of "qualifier"?](https://stackoverflow.com/questions/3785789/what-is-the-meaning-of-qualifier)   
- [\[cppreference\] cv (const and volatile) type qualifiers](https://en.cppreference.com/w/cpp/language/cv)   
- [\[cppreference\] const type qualifier](https://en.cppreference.com/w/c/language/const)   
- [\[cppreference\] volatile type qualifier](https://en.cppreference.com/w/c/language/volatile)   
- [\[cppreference\] Non-static member functions](https://en.cppreference.com/w/cpp/language/member_functions)